##知识点

- 页面加载过程

- 性能优化

- 安全性



##题目

- 从输入url到得到html的详细过程

- window.onload和DOMContentLoaded的区别

    - window.onload页面资源全部加载完才会执行，包括图片、视频等

    - DOMContentLoaded在DOM渲染完即可执行，此时图片、视频还可能没有加载完



##知识点

- 加载资源的形式

    - 输入url（或跳转页面）加载html
    
    - 加载html中的静态资源(css，js，图片，视频，字体文件)


- 加载一个资源的过程

    - 浏览器根据DNS服务器得到域名的IP地址
    
    - 向这个IP的机器发送http请求
    
    - 浏览器收到、处理并返回http请求
    
    - 浏览器得到返回内容


- 浏览器渲染页面的过程

    - 根据html结构生成DOM Tree
    
    - 根据CSS生成CSSOM
    
    - 将DOM和CSSOM整合形成RenderTree
    
    - 根据RenderTree开始渲染和展示
    
    - 遇到`<script>`时，会执行并阻塞渲染


- 重排和重绘

浏览器下载完页面中的所有组件(html标记、Javascript、CSS、图片)之后会解析生成两个内部数据结构——DOM树和渲染树。

DOM树表示页面结构，渲染树表示DOM节点如何显示。DOM树中的每一个需要显示的节点在渲染树中至少存在一个对应的节点(隐藏的DOM元素 display:none 在渲染树中没有对应的节点)。

渲染树中的节点被称为‘帧’或‘盒’，符合CSS模型的定义，页面元素为一个具有填充，边距，边框和位置的盒子。一旦DOM树和渲染树构建完成，浏览器就开始绘制页面元素。

当DOM的变化影响了元素的几何属性(宽或高)，浏览器需要重新计算元素的几何属性，同时其他元素的几何属性和位置也会受到影响。浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树，这个过程称为重排。完成重排后，浏览器会重新绘制受到影响的部分到屏幕，这个过程称为重绘。

由于浏览器的流布局，对渲染树的计算通常只需要遍历一次就可以完成。table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花三倍同等元素的时间。这也是为什么我们要避免使用table做布局的一个原因。

并不是所有的DOM变化都会影响几何属性，比如改变一个元素的背景色并不会影响元素的宽和高，这种情况下只会发生重绘。

    - 重排何时发生
    
        - 添加或删除可见的DOM元素
        
        - 元素位置改变
        
        - 元素尺寸改变
        
        - 元素内容改变
        
        - 页面渲染初始化
        
        - 浏览器窗口尺寸改变
        
- 渲染树变化的排队和刷新

获取布局信息的操作会导致队列刷新，比如：

a、offsetTop,offsetLeft,offsetWidth,offsetHeight

b、scrollTop,scrollLeft,scrollWidth,scrollHeight

c、clientTop,clientLeft,clientWidth,clientHeight

d、getComputeStyle()||currentStyle(IE)

因为offsetHeight属性需要返回最新的布局信息，因此浏览器不得不执行渲染队列中的“待处理变化”并触发重排以返回正确的值（即使队列中 改变的样式属性和想要获取的属性值并没有什么关系）。

- 最小化重排和重绘

改变元素多种样式的时候，最好用className，一次性完成操作，这样只会修改一次DOM。

- 重排和重绘是DOM编程中耗能的主要原因之一，为了避免不必要的性能损耗可以参考一下几点：

尽量不要在布局信息改变时做查询(会导致渲染队列强制刷新);

同一个DOM的多个属性改变可以写在一起(减少DOM访问，同时把强制渲染队列刷新的风险降为0);

如果要批量添加DOM，可以先让元素脱离文档流，操作完成后带人文档流，这样只会触发一次重排(fragment元素的应用);

将需要多次重排的元素，添加定位属性，设置为absolute,fixed，这样此元素就脱离了文档流，不会影响其他元素。

使用绝对位置定位页面上的动画元素，将其脱离文档流。这样不会导致文档流中的元素受到影响，不会大规模的进行重排和重绘。






###思考

- 为何要把js放到body最下面

    - 不会阻塞，性能更好
    
    - 方便获取DOM的标签





##性能优化


###原则

- 多使用内存、缓存或者其他方法

- 减少使用cpu计算，减少网络请求


###从哪里入手

- 加载页面和静态资源

- 页面渲染



###加载资源优化

- 静态资源的压缩合并

- 静态资源缓存

- 使用CDN让资源加载更快

- 使用SSR后端渲染，数据直接输出到HTML中



###渲染优化

- CSS放前面，JS放后面

- 懒加载（图片懒加载、下拉加载更多）

- 减少DOM查询，对DOM查询做缓存

- 减少DOM操作，多个操作尽量合并在一起执行

- 事件节流

- 尽早执行操作（如DOMContentLoaded）




##示例


###资源合并

![](/assets/360截图20171004172848579.jpg)



###缓存

![](/assets/360截图20171004173132828.jpg)




###CDN

![](/assets/360截图20171004173437462.jpg)


###使用SSR后端渲染

![](/assets/360截图20171004173905804.jpg)



###懒加载

![](/assets/360截图20171004174015631.jpg)



###缓存DOM查询
    
![](/assets/360截图20171004174314854.jpg)



###合并DOM插入

![](/assets/360截图20171004174737546.jpg)




###事件节流

![](/assets/360截图20171004174935697.jpg)



###尽早执行操作

![](/assets/360截图20171004175810990.jpg)







##安全性

- 综合性的问题：场景的前端安全问题有哪些




###知识点

- XSS跨站请求攻击

- XSRF跨站请求伪造



###XSS

- 在新浪博客写一篇文章，同时偷偷插入一段`<script>`

- 攻击代码中，获取cookie，发送到自己的服务器

- 发布博客，有人查看博客内容

- 会把查看者的cookie发送到攻击者的服务器



###防XSS

- 前端替换关键字，例如替换`<为&lt;>为&gt;`

- 后端替换




###XSRF

![](/assets/360截图20171005142504409.jpg)

![](/assets/360截图20171005142630018.jpg)






##技巧



###简历

- 简洁明了，重点突出项目经历和解决方案

- 把个人博客放在简历中，并且定期维护更新博客

- 把个人的开源项目昂在简历中，并维护开源项目

- 简历千万不要造假，要保持能力和经历上的真实性




![](/assets/360截图20171005144524147.jpg)
